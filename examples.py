# coding: utf8

# изучение функции sorted
# примеры из этого файла лучше выполнять по одному, а не запускать весь файл целиком

# функция sorted принимает на вход один обязательный аргумент и три необязательных
# первый - то, что нужно отсортировать. Это что-то должно быть итерируемым, то есть оно должно поддерживать цикл for
# над собой
# пример

print sorted([5, 4, 3, 2, 1])
# выведет [1, 2, 3, 4, 5]

# или так

l = ['a', 'c', 'b', 'aa']
s = sorted(l)
print s

# выведет ['a', 'aa', 'b', 'c']

# с первым необязательным аргументом мы познакомимся чуть позже, а пока перейдем ко второму. Его можно задать, определив
# арумент key у функции sorted. Этот арумент - функция с одним арументом. На вход этой функции пойдет каждый
# из элементов последовательности, которая передана в первом аргументе функции sorted. Функция, переданная в key
# может возвращать что угодно. Сортировка исходных элементов будет производить по значениям, которые возвращает
# переданная в key функция

# пример
d = {1: "d", 2: "c", 3: "a", 4: "b"}
# сохраним в переменную d_items пары ключ-значение
d_items = d.items()
# и отсортируем эти пары по второму элементу в паре

l = sorted(d_items, key=lambda x: x[1])
print l

# получится [(3, 'a'), (4, 'b'), (2, 'c'), (1, 'd')]

# как это работает
#
# функция lambda x: x[1] получает на вход кортеж из двух элементов и возращает второй из этих элементов.
# Поэтому сортировка значений происходит по второму элементу кортежа. То есть мы получили словарь, отсорированный
# по значеням, потому что в d_items у нас лежали пары ключ-значение словаря

# третий необязательный аргумент функции sorted - reverse. Он меняет порядок сортировки с по возрастанию на по убыванию

l = sorted(d_items, key=lambda x: x[1], reverse=True)
print l

# теперь выведется [(1, 'd'), (2, 'c'), (4, 'b'), (3, 'a')], то есть сортировка по убванию значений словаря

# можно сортировать сколь угодно сложные конструкции, достаточно написать правильную функцию, которую затем
# передать в keys

# например пусть у нас есть списко с другими другими длины 3

my_list = [[3, 2, 1], [1, 3, 2], [1, 2, 3], [3, 1, 2]]

# и пусть мы хотим осотртировать элементы этого списка по третьему элементу. Тогда достаточно сделать вот так

# сохраним отсортированный список в переменную sorted_my_list и выведем ее
sorted_my_list = sorted(my_list, key=lambda x: x[2])
print sorted_my_list

# получится [[3, 2, 1], [1, 3, 2], [3, 1, 2], [1, 2, 3]]
# видно, что элементы исходно списка идут в таком порядке, что третий элемент каждого из них возрастает

# чуть более сложный пример. Пусть у нас есть список словарей, каждый из которых содержит ключ 'my'

list_with_dicts = [
    {'my': 5, 'your': 7},
    {'a': 'c', 'my': 1},
    {'b': -10, 'my': -10, 'your': -10},
    {'my': 10}
]

print sorted(list_with_dicts, key=lambda x: x['my'])

# выведется список [{'b': -10, 'my': -10, 'your': -10}, {'a': 'c', 'my': 1}, {'my': 5, 'your': 7}, {'my': 10}]
# при этом он выведется и ни в какую переменную не сохранится, потому что мы не записали результат сортировки
# ни в какую переменную

# теперь попробуем отсортировать по значению в ключу 'your'

print sorted(list_with_dicts, key=lambda x: x['your'])

# этот код упадет с ошибкой
# >>> print sorted(list_with_dicts, key=lambda x: x['your'])
# Traceback (most recent call last):
#   File "<input>", line 1, in <module>
#   File "<input>", line 1, in <lambda>
# KeyError: 'your'

# Он пишет KeyError: 'your'.    KeyError обычно означает, что у словаря пытались взять значение по ключу, который
# указан в KeyError, и такого ключа у словаря не нашлось. Что же произошло в нашем случае.
# Функция lambda x: x['your'] берет каждый из элементов входного списка. В нашем случае это словари. Потом эта функция
# вызывается с аргументом - элементом, на который сейчас смотрит. В нашем случае это словарь. И наша функция пытается
# взать у словаря значение по ключу 'your' у каждого словаря из списка. А такой ключ есть не у всех словарей из этого
# списка. И как только функция lambda x: x['your'] вызывается от словаря, в котором нет ключа 'your', наш код падает
# и сообщает нам о том, что он не нашел в словаре ключа 'your'

# теперь про загадочный второй необязательный аргумент функции sorted() и о том, почему сегодня весь день ничего
# не работало. Аргументы функции sorted() можно посмотреть в официальной документации
# https://docs.python.org/2/library/functions.html#sorted
# там написано так
# sorted(iterable[, cmp[, key[, reverse]]])

# то есть у функции 4 аргумента, при этом необязательные аргументы указываются в квадратных скобках, поэтому
# обязательный только один - что сортировать.

# второй аргумент - cmp. Это функция, сравнения двух элементов между собой. Она принимает на вход два аргумента -
# два элемента последовательности. И выдает нечто, о чем мы сейчас разговаривать не будем. Важно только то, что
# ей нужно подавать на вход функцию от двух аргументов.

# Теперь о том, почему не работало, когда не было явно указано keys

# Вызовем функцию sorted, не указав keys
# >>> print sorted(list_with_dicts, lambda x: x['my'])
# Traceback (most recent call last):
#   File "<input>", line 1, in <module>
# TypeError: <lambda>() takes exactly 1 argument (2 given)

# как нас понял питон. В описании функции сказано, что sorted(iterable[, cmp[, key[, reverse]]])
# то есть обязательный первый аргумент. Если остальные аргументы есть и они не именованные, то есть
# например мы вызвали функцию так
# sorted([1, 2, 3], f), где f - какая-то функция, то питон пройдется по аргументам функции sorted, и просвоит
# им значения слева направо, то есть iterable заполнится значением [1, 2, 3], cmp заполнится значением f. Значения
# key и reverse примут значения по умолчанию, которые скорее всего равны None и False.

# если же мы не хотим пропустить задание агрумента cmp, то надо явно об этом указать питону. Нужно сказать
# "я хочу задать аргумент key, а аргумент cmp я не задаю, пусть он будет равен значению по умолчанию". Делается это так
my_list = [[3, 2, 1], [1, 3, 2], [1, 2, 3], [3, 1, 2]]
print sorted(my_list, key=lambda x: x[2])

# или так, что то же самое, но с предварительным сохранением lambda функции в переменную f. Переменная f после этого
# тоже будет функцией, только у нее будет имя. Можно, например, будет вызвать f([1, 2, 3]) и вернется тройка

f = lambda x: x[2]
print sorted(my_list, key=f)
print f([1,2, 3])

# это то же самое, что сначала определить функцию, а потом ее передать в sorted


def f2(x):
    return x[2]


print sorted(my_list, key=f2)

# Вроде все. Теперь задачи

# 1) выполнить команду
from string import ascii_lowercase
d = dict(zip(range(1, 27), ascii_lowercase)) # о том, как это работает - чуть поже, а пока достаточно знать, что этот
# словарь отображает числа от 1 до 26 в букву  английского алфавита с таким номером (их всего 26)
# например
print d[1]  # выведет букву a
print d[26]  # выведет букву z

# Теперь, собственно, задача. Надо вывести этот список в виде
# z 26
# y 25
# ...
# то есть в порядке убвания ключей, сначала ключ, потом значение.
# Как делать. Надо сделать из словаря пары ключ - значение, потом правильно вызвать функцию sorted, результат ее работы
# сохранить в какую-нибудь переменную. Потом в цикле вывести пары. Значение, пробел, ключ.


# 2) Отсортировать множество котрежей по второму элементу этого кортежа в обратном порядке. Вывести кортежи через
# перевод строки. Замечание - сортировать можно все, что поддерживает обход в цикле. Поэтому множества тоже можно
my_set = set([(1,2), (2, 1, 3), (1, -4), (2, 4)])

# 3) отсортировать список одноэлементных сильно вложенных кортежей
my_tuples = [(('b',),), (('c',),), (('a',),)]

# запись сильно дурацкая, но на практике встречается. Тут каждый элемент - это кортеж из одного элемента, который тоже
# в свою очередь кортеж из одного элемента. Котеж из одного элемента (например из единицы)
# в питоне обозначатеся так t = (1,). Если же написать t = (1), то питон просто приравняет t единице. Поэтому запятая
# важна.

# 4) отсортировать словари по убыванию значения в ключе 'a', возведенному в квадрат (важно!)
my_dicts = [{'b': 5, 'a': -10}, {'c': 10, "a": 0}, {'a': 5}]

# надо заметить, что питону все равно, в каких скобках записаны строки. Можно в одинарных 'a', можно в двойных "a",
# поэтому в этом примере и так, И так.

